#pragma once
#include <iostream>

using namespace std;

using std::cout;
using std::cin;
using std::endl;

#pragma region 가상 함수
/*
▶ 가상 함수란?

- 부모 클래스의 특정 함수가 자식 클래스에 재정의 되어 있을 경우
  부모 클래스의 참조 또는 포인터를 가지고 자식 클래스의 특정 함수를 실행 시키는 매커니즘을 의미한다.

- 가상 함수를 이용하면 객체의 계층 구조에 따라 자식 클래스의 특정 함수를 호출하는것이 가능하다.

▷ 가상 함수 특징

- C++ 클래스의 특성중 하나인 다형성을 지원하기 위해 "virtual" 키워드를 사용한다.

- 부모 클래스내에서 virtual로 선언된 함수는 자식 클래스에서 재정의 될 수 있다. (오버라이딩)

※ 재정의 되지 않았다면 호출시 부모 클래스의 함수가 호출이 되고 재정의 되었다면 함수 호출 시 자식 클래스의 함수가 호출된다. (가상 함수 테이블)

▷ 다형성? (하나의 클래스가 여러가지의 일을 유연히 할 수 있음)

- 여러가지를 포현할 수 있다는 뜻

- 자식 객체의 인스턴스를 부모 객체의 타입으로 간접 지정이 가능하다는걸 뜻한다.


▷ 인스턴스?
- 어느 클래스에 속하는 각 객체를 인스턴스라고 한다.

EX)
- 집이라는 클래스를 만들고 내 방이라는 객체를 생성하면 그 클래스의 인스턴스가 생성된다.

※ 함수 오버로딩 + 함수 오버라이딩

*/
#pragma endregion

// 부모
class weapon
{

public:
	// 자식클래스도 virtual을 쓰면 그만이지만 부모클래스에서만 virtual를 사용하면서 실행속도와 메모리 절약을 챙겼다.
	virtual void attack() { cout << "무기로 공격" << endl; }
};

class gun : public weapon
{

public:
	void attack() { cout << "총으로 공격" << endl; }
};

class bow : public weapon
{

public:
	void attack() { cout << "활로 공격" << endl; }
};

class AClass
{
public:
	
	//void myFunc() { cout << "내가 A 클래스" << endl; }

	// 순수 가상함수 : 함수의 몸체가 정의되지 않는 함수
	virtual void classFunc() = 0;


	// - 0은 대입이 아닌 명시적으로 몸체를 정의하지 않겠다는 의미
	// - 순수 가상함수로만 만들어진 클래스를 인터페이스라고 부른다.
	//   ㄴ 인터페이스는 인스턴스를 생성할 수 없다.

	// 인터페이스는 한정자(const 등)를 사용할 수 없다.


	AClass() {}
	// 인터페이스에서 가상 소멸자는 필수!! (없으면 메모리 릭 발생)
	virtual ~AClass() {}

	/*
	▶ 상속 관계에서의 생성과 소멸

	- 상속을 받은 클래스의 생성과 소멸 과정에는 동일한 규칙이 적용된다.
	 ㄴ 부모 클래스의 생성자에서 자식 클래스의 생성자 순서로 호출이 되고
	   소멸자는 자식 클래스의 소멸자가 먼저 호출이 되면서 부모 클래스의 소멸자가 호출이 되는 구조를 가지고 있다.

	- 부모 클래스의 포인터로 자식 클래스를 호출할때 가상 함수로 정의되어 있지 않은 자식 클래스의 오버라이딩된 함수를 호출하면
	  부모 클래스의 멤버 함수가 호출이 된다. 이를 "다형성"이라고 했었다.

	- 소멸자도 자식 클래스에서 오버라이딩된 함수라고 볼 수 있기 때문에
	  만약 부모 포인터로 객체를 삭제하면 부모 클래스의 소멸자가 호출이 된다.

	- 따라서 소멸자를 가상 함수로 선언하지 않으면 다형성 매커니즘이 동작하지 않기 때문에 자식 클래스의 소멸자는 결코 호출이 되지 않는 불상사가 발생한다.
	  ㄴ 이는 곧 메모리 누수 당첨!!

	- 가상 함수 키워드를 사용했다면 이것은 자식 클래스에서 재정의될 수 있음을 명시한것이기 때문에
	  포인터의 종류에 상관없이 자식클래스의 함수가 호출되는 결과를 볼 수 있다.(재정의 되었다면.)

	※ 자식 클래스 소멸자 호출 -> 부모 클래스의 소멸자를 호출하기 위해
		ㄴ 소멸자에서 해제가 필요한 경우 (상속 관계) 소멸자에 가상화를 고민해 봐야 한다.
	*/

};

class MainGame_04
{
private:
	// 각자의 클래스를 참조하는것이 아닌 부모클래스로 참조 (C++에서만 가능 - 포인터를 사용하기 때문에 / 그리고 아주 강력한 기능)
	// 재생산성이 UPUPUPUPUPUPUPUP
	weapon* _gun;
	weapon* _bow;
	weapon* _myWeapon;


public:
	MainGame_04();
	~MainGame_04();
};


/*
과제 1. 숫자 야구 클래스로 나누기

- 두가지 버전
 ㄴ 1. 가상화가 있는 버전 1개
 ㄴ 2. 클래스가 최소 8개 있는 버전 1개

- 메인 함수에서 클래스를 선택해 원하는 버전을 플레이 할 수 있게 만든다.


과제 2. 포트폴리오 선행 작업

- 도트를 추천

※ 복습은 꼭 한다.


열심히 조사.

- 노트에 적어온다.

- STL + 자료 구조 + 스택 + 큐 + 트리 + 백터 + 리스트 + 맵 + 반복자 + 컨테이너

*/

